---
title: "Plaice_WHAM"
output: html_document
---

# Data
Data sourced from 2019 VPA update (2019_PLA_UNIT_MOD_VPA_T2018_NEC_ONLY.dat file from https://apps-nefsc.fisheries.noaa.gov/saw/sasi/sasi_report_options.php), manually converted to ASAP .dat format

## VPA only
PARAM: 39  11  30  17  10  1980  1  0  123456 
- unclear how this is used

Partial recruitment: 0.00  0.05  0.05  0.25  0.76  1.00  1.00  1.00  1.00  1.00
- presumably recruitment to fishery (ages 6-10 fully selected by fishery)

Stock estimate: 100  100  100  2000.  9000.  5000.  5000.  5000.  1000  500 
- presumably starting stock estimate

Stock min-max: 1.0000E+00  1.0000E+06

F-Plus: 1.00000*39 

Ages-F: 6-9

MFSpawn: 0.2500 0.2500

Checked Index: 1  2  3  4  5  6  7  8  9  11  12  13  14  15  16  17  18  

Checked Retro: 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  

Options: 1  0  0  1  1  1  0  1  0  5

Xparm: 80 1

## WHAM model setup
### Years
1980 - first year
2018 - last year of assessment
2019 - data available for some but not all surveys, no catch data available for this year (from VPA)
39 - total years in assessment
### Population
1-11+ Ages
0.2 Fixed natural mortality-at-age
Jan-01 SSB calculated
1 Maturity-at-age matrix
1 Weight-at-age matrix
No discards or release data
### Surveys
4 Surveys included (spring/fall NEFSC bottom trawl, spring/fall MA) - likely want to compare to version without the MA surveys

From VPA:
  spr_ma = Spring Massachusetts survey
  ma#aut = Fall Massachusetts survey
  spr_us = Spring NEFSC bottom trawl survey
  us#aut = Fall NEFSC bottom trawl survey
  1-8,9+ ages for spring NEFSC
  0-7,8+ ages for fall NEFSC - lagged forward a year to match cohorts in spring survey
  1-5 spring and fall MA DMF

### Fishery
1 Fleet
1 Selectivity block
Logistic selectivity
6-11 Ages used to calculate average F (unweighted)
1 Release mortality
1 Catch-at-age matrix from first to last year (combined landings & discards)

Notes from 2012 update
- fishery mostly in 2nd and 3rd quarters - catch half way through year would be appropriate
- back-calculated partial recruitment flat topped 1980-1993, 1994-2001, 2002-2010 (fully recruited F shift from 5 to 6)

## Translate data into format for WHAM
Assume - unchanged options inherited values from cod example & need to be checked agains SAW documentation
- Number of Sensitivity Blocks = 1 unchanged ??? revisit
- Fecundity Option = 0 unchanged ??? revisit
- Weights at Age Pointers = unchanged ??? revisit
- Selectivity Block Assignment = unchanged = 1 for Fleet 1 ??? revisit
  - Single selectivity block
- Selectivity Options for each block = 2 = logistic = unchanged ??? revisit
- Selectivity Block # 1 Data? Not sure what each line is ??? revist (currently unchanged but should be updated)
  - Presumably column 1 = data, 2 = phase, 3 = unused setting, 4 = error or variance
- Use Likelihood constants = 0 = unchanged ??? revisit
- Release Mortality by Fleet = 1= unchanged ??? revisit, may not matter since no release data provided
- Aggregate Index Units = 2 = unchanged, make sure this corresponds with numbers ??? revisit
- Age Proportion Index Units = 2 = unchanged ??? revisit
- Index Month = 4 10 4 10 = for spring/fall NEFSC, spring/fall MADMF double-check ???
- Index Selectivity Link to Fleet = unchanged -1 ???revisit
- Index Selectiity Options = unchanged 1 = by age ??? revisit
- Index Start Age = 1
- Index End Age = 9, index has 9:11 I am not sure how to specify aggregated 
- Estimate Proportion = unchanged 1 = yes ??? revisit
- Use Index = unchanged 1 = yes ??? revisit
- Index -1 Selectivity data? Not sure what each line is??? revisit (currently unchanged but should be updated)
  - Presumably column 1 = data, 2 = phase, 3 = unused setting, 4 = error or variance
  - Probably need to replicate for other indices
  - Dublicated perfectly for all 4 indices, what do rows correspond to?
- Index-1 Data - unclear how to specify?
  - Presumably year, total aggregated index, variance, age specific observations, effective sample size? check ???
  - Unclear why 9:11 and 9 age columns for NEFSC fall survey? I only included 1-8 and 9:11 columns
  - Used cod default CV & final column
- Phase for F mult in 1st year = 1, unchanged
- Phase for F mult Deviations = 3, unchanged
- Phase for N in 1st year = 1, unchanged
- Phase for Catchability in 1st year = 1, unchanged
- Phase for Catchability deviations = -3, unchanged ??? revisit
- Phase for Stock Recruitment Relationship = 2, unchanged
- Phase for Steepness = -1, unchanged ??? revisit
- Recruitment CV by year = 0.5, unchanged ??? revisit
- Lambdas by Index = 1, unchanged ??? revisit
- Lambda for Total Catch in Weight by Fleet = 1, unchanged ??? revisit
- Lambda for Total Discards at Age by Fleet = 0, unchanged no discards
- Catch Total CV by Year and Fleet = 0.05, unchanged ??? revisit
- Discard Total CV by Year and Fleet = 0, unchanged no discards
- Catch Effective Sample Size by Year and Fleet = 65, unchanged ??? revisit
- Discard Effective Sample Size by Year and Fleet = 0, unchanged no discards
- Lambda for F Mult in First year by Fleet = 0, unchanged ??? revisit
- CV for F Mult in First year by Fleet = 0.1, unchanged ??? revisit
- Lambda for F Mult Deviations by Fleet = 0, unchanged ??? revisit
- CV for F Mult Deviations by Fleet = 0.1, unchanged ??? revisit
- Lambda for N in 1st Year Deviaions = 0, unchanged ??? revisit
- CV for N in 1st Year Deviations = 0.1, unchanged ??? revisit
- Lambda for Recruitment Deviaitons = 0, unchanged ??? revisit
- Lambda for Catchability in First year by Index = 0, unchanged ??? revisit
- CV for Catchability in First year by Index = 0.2, unchanged ??? revisit
- Lambda for Catchability Deviations by Index = 0, unchanged ??? revisit
- CV for Catchability Deviations by Index = 0.1, unchanged ??? revisit
- Lambda for Deviation from Initial Steepness = 0, unchanged ??? revisit
- CV for Deviation from Initial Steepness = 0.1, unchanged ??? revisit
- Lambda for Deviation from Unexploited Stock Size = 0, unchanged ??? revisit
- CV for Deviation from Unexploited Stock Size = 0.1, unchanged ??? revisit
- NAA Deviaitons Flag = 1, unchanged ??? revisit
- Initial Numbers at Age in 1st Year = based on VPA STOCK ASSESSMENT = 100  100  100  2000.  9000.  5000.  5000.  5000.  1000  500  Changed based on JJD recomendation
- Initial F Mult in 1st Year by Fleet = 0.2, unchanged ??? revisit
- Initial Catchability by Index = 1, unchanged ??? revisit
- Stock Recruitment Flag = 0, unchanged ??? revisit
- Initial Unexploited Stock = 10000, unchanged ??? revisit
- Initial Steepness = 1, unchanged??? revisit
- Maximum F = 5, unchanged ??? revisit
- Ignore Guesses = 0, unchanged = no ??? revisit
- Projection control do projections = 0, unchanged
- Fleet Directed Flag = 1, unchanged ??? revisit
- Final Year in Projection = 2018 since not projected, revisit ???
- Projection Data by Year placeholder data unchanged, revisit ???

# Load R packages
```{r}
library(tidyverse)
library(wham)
```

# Read in data for use in WHAM
## Fit WHAM
CANNOT add comments at end of lines (comments must be separate lines)
```{r}
# Load data
asap3 <- read_asap3_dat("Plaice.dat")
# asap3 <- read_asap3_dat("Plaice_JJD2.dat")

# Prep WHAM input
input <- prepare_wham_input(asap3) # Problem reading last column of asap3$IAA_mats?

# Fit plaice model
plaice_model <- fit_wham(input, MakeADFun.silent = TRUE) # https://timjmiller.github.io/wham/articles/ex7_debug.html # do.fit = F returns an error
check_convergence(plaice_model)

input <- prepare_wham_input(asap3 = asap3,
                            recruit_model = 2,
                            model_name = "Initial_Plaice",
                            selectivity = list(c("age-specific", "age-specific", "age-specific", "age-specific"),
                                               re = c("none", "none", "none", "none"),
                                               initial_pars = list(c(0.02,0.47,0.88,1,1,1,1,1,1,1,1), c(0.02,0.47,0.88,1,1,1,1,1,1,1,1), c(0.02,0.47,0.88,1,1,1,1,1,1,1,1), c(0.02,0.47,0.88,1,1,1,1,1,1,1,1)),
                                               fix_pars = list(6:9, 6:9, 5, 5:6)),
                            NAA_re = list(sigma="rec", cor="iid"))




# Cod example
asap3 <- read_asap3_dat(paste(here::here(), "Gulf_of_Maine_cod_WHAM_example", "codGOM.dat", sep="/"))
input1 <- prepare_wham_input(asap3, recruit_model=2, model_name="GOM Cod",
                             selectivity=list(model=rep("age-specific",2), 
                                              re=rep("none",2), 
                                              initial_pars=list(c(0.013, 0.066, 0.271, 0.663, 0.912, 0.982, 0.997, 1, 1),c(0.038, 0.134, 0.289, 0.531, 0.778, 1, 1, 1, 1)),  
                                              fix_pars=list(7:9,6:9)),
                             NAA_re = list(sigma="rec", cor="iid"))
mcod <- fit_wham(input1, do.osa = F, MakeADFun.silent = TRUE)
check_convergence(mcod)

mcod_proj <- project_wham(model=mcod)
plot_wham_output(mod=mcod, out.type='html')
```

## WHAM with only NEFSC trawl surveys (excludes MA DMF as in 2018 assessment update)
### First & second iterations
```{r}
# Setwd for this model run
setwd(paste(here::here(), "Model_runs", sep="/"))

# Load data
asap3 <- read_asap3_dat(paste(here::here(), "Plaice_noMADMF.dat", sep="/"))

# Prep WHAM input
input1 <- prepare_wham_input(asap3, model_name = "Plaice_noMADMF") 

# Fit plaice model
plaice_model1 <- fit_wham(input1, MakeADFun.silent = TRUE) # https://timjmiller.github.io/wham/articles/ex7_debug.html # do.fit = F returns an error
check_convergence(plaice_model)


##### Model with fixed selectivity for indices (indices = 4&5)
# Load data
asap3 <- read_asap3_dat(paste(here::here(), "Plaice_noMADMF.dat", sep="/"))

# Prep WHAM input
input2 <- prepare_wham_input(asap3, model_name = "Plaice_noMADMF2",
                             selectivity=list(model=c("logistic", "age-specific","age-specific"), # want fishery logistic
                                  re=rep("none",3), 
                                  initial_pars=list(c(2,0.2),c(0.5,0.5,0.5,1,1,0.5,0.5,0.5,0.5,0.5,0.5),c(0.5,0.5,0.5,1,1,0.5,0.5,0.5,0.5,0.5,0.5)), 
                                  fix_pars=list(c(0),c(4,5),c(4,5)))) 

# Fit plaice model
plaice_model2 <- fit_wham(input2, MakeADFun.silent = TRUE) # https://timjmiller.github.io/wham/articles/ex7_debug.html # do.fit = F returns an error
check_convergence(plaice_model2)

# Generate diagnostics
plot_wham_output(mod = plaice_model2, out.type = 'html')
```

### Third iteration to fix selectivity based on example.R
Fix selectivity for age 9, update starting selectivity values, add random effect for NAA
```{r}
# Setwd for this model run
setwd(paste(here::here(), "Model_runs", sep="/"))

##### Data
# Load data
asap3 <- read_asap3_dat(paste(here::here(), "Plaice_noMADMF.dat", sep="/"))
# iid random effects for recruitment only 
NAA_re = list(sigma = "rec") #random about mean
NAA_re$recruit_model = 2 #random effects with a constant mean
NAA_re$recruit_pars = exp(10) #initial guess for mean recruitment
# Selectivity
init_fleet_sel <- list(c(2,0.4)) # logistic, same as in the asap dat file
fix_index_sel = lapply(1:asap3$dat$n_indices, function(x) 9) # Index NA means do not fix them
fix_fleet_sel = lapply(1:asap3$dat$n_fleets, function(x) NA) #need this for fleets
init_index_sel = lapply(1:asap3$dat$n_indices, function(x) c(rep(0.5,8),1,0,0))
sel_list <- list( model=c(rep("logistic", asap3$dat$n_fleets), rep("age-specific", asap3$dat$n_indices) ),
                  #re=c( rep("none", 1), "2dar1", rep("none", 3) ) ,
                  #re=c( rep("none", 1),  rep("2dar1", 4) ) ,
                  initial_pars=c(init_fleet_sel, init_index_sel) ,
                  fix_pars=c(fix_fleet_sel, fix_index_sel))

##### Prep WHAM input
input3 <- prepare_wham_input(asap3 = asap3, NAA_re = NAA_re, selectivity = sel_list, model_name = "Plaice_noMADMF3")

###### Fit plaice model
plaice_model3 <- fit_wham(input3, do.osa = FALSE,do.retro=FALSE,do.check=TRUE, MakeADFun.silent = TRUE) #do.check will suggest where to look for and parameters that are challenging to estimate in current config
check_convergence(plaice_model3)

# Generate diagnostics
plot_wham_output(mod = plaice_model3, out.type = 'html')

# Look at selectivity patterns 
plaice_model3$rep$selAA[[2]][1,] #index 1 selectivity
plaice_model3$rep$selAA[[3]][1,] #index 2 selectivity. compare with lines 50-51
```
Still looks like dome-selectivity for indices but 9+ group has higher selectivity since grouped
- The above fixed full selectivity to age 9, looks like age 4 for index 1, age 5 for index 2

### Fourth iteration fix age 4 and 5 for indices 1 and 2 respectively
```{r}
# Setwd for this model run
setwd(paste(here::here(), "Model_runs", sep="/"))

##### Data
# Load data
asap3 <- read_asap3_dat(paste(here::here(), "Plaice_noMADMF.dat", sep="/"))
# iid random effects for recruitment only 
NAA_re = list(sigma = "rec") #random about mean
NAA_re$recruit_model = 2 #random effects with a constant mean
NAA_re$recruit_pars = exp(10) #initial guess for mean recruitment
# Selectivity
init_fleet_sel <- list(c(2,0.4)) # logistic, same as in the asap dat file
fix_index_sel[[1]][1] <- 4 # Index NA means do not fix them
fix_index_sel[[2]][1] <- 5
fix_fleet_sel = lapply(1:asap3$dat$n_fleets, function(x) NA) #need this for fleets
init_index_sel[[1]] <- c(0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0, 0)
init_index_sel[[2]] <- c(0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.5, 0, 0)
sel_list <- list( model=c(rep("logistic", asap3$dat$n_fleets), rep("age-specific", asap3$dat$n_indices) ),
                  #re=c( rep("none", 1), "2dar1", rep("none", 3) ) ,
                  #re=c( rep("none", 1),  rep("2dar1", 4) ) ,
                  initial_pars=c(init_fleet_sel, init_index_sel) ,
                  fix_pars=c(fix_fleet_sel, fix_index_sel))

##### Prep WHAM input
input4 <- prepare_wham_input(asap3 = asap3, NAA_re = NAA_re, selectivity = sel_list, model_name = "Plaice_noMADMF4")

###### Fit plaice model
plaice_model4 <- fit_wham(input4, do.osa = FALSE,do.retro=FALSE,do.check=TRUE, MakeADFun.silent = TRUE) #do.check will suggest where to look for and parameters that are challenging to estimate in current config
check_convergence(plaice_model4)

# Generate diagnostics
plot_wham_output(mod = plaice_model4, out.type = 'html')

# Look at selectivity patterns 
plaice_model4$rep$selAA[[2]][1,] #index 1 selectivity
plaice_model4$rep$selAA[[3]][1,] #index 2 selectivity. compare with lines 50-51
```
Worse fit, ages 4 and 5 (for index 1 and 2 respectively) and age 9+ at 1
- age comp residuals small for larger ages, try fixing age 9 at estimated value for age 8

### Fifth iteration builds on iteration 3
Fix selectivity for age 9 near estimate for age 8 from plaice_model3 (0.49969888, 0.516221002), fix ages 4 and 5 (index 1 and 2 respectively) at 1
```{r}
# Setwd for this model run
setwd(paste(here::here(), "Model_runs", sep="/"))

##### Data
# Load data
asap3 <- read_asap3_dat(paste(here::here(), "Plaice_noMADMF.dat", sep="/"))
# iid random effects for recruitment only 
NAA_re = list(sigma = "rec") #random about mean
NAA_re$recruit_model = 2 #random effects with a constant mean
NAA_re$recruit_pars = exp(10) #initial guess for mean recruitment
# Selectivity
init_fleet_sel <- list(c(2,0.4)) # logistic, same as in the asap dat file
fix_index_sel <- NULL
fix_index_sel[[1]] <- c(4,9) # Index NA means do not fix them
fix_index_sel[[2]] <- c(5,9)
fix_fleet_sel = lapply(1:asap3$dat$n_fleets, function(x) NA) #need this for fleets
init_index_sel[[1]] <- c(0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0, 0)
init_index_sel[[2]] <- c(0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.5, 0, 0)
sel_list <- list( model=c(rep("logistic", asap3$dat$n_fleets), rep("age-specific", asap3$dat$n_indices) ),
                  #re=c( rep("none", 1), "2dar1", rep("none", 3) ) ,
                  #re=c( rep("none", 1),  rep("2dar1", 4) ) ,
                  initial_pars=c(init_fleet_sel, init_index_sel) ,
                  fix_pars=c(fix_fleet_sel, fix_index_sel))

##### Prep WHAM input
input5 <- prepare_wham_input(asap3 = asap3, NAA_re = NAA_re, selectivity = sel_list, model_name = "Plaice_noMADMF5")

###### Fit plaice model
plaice_model5 <- fit_wham(input5, do.osa = FALSE,do.retro=FALSE,do.check=TRUE, MakeADFun.silent = TRUE) #do.check will suggest where to look for and parameters that are challenging to estimate in current config
check_convergence(plaice_model5)

# Generate diagnostics
plot_wham_output(mod = plaice_model5, out.type = 'html')

# Look at selectivity patterns 
plaice_model5$rep$selAA[[2]][1,] #index 1 selectivity
plaice_model5$rep$selAA[[3]][1,] #index 2 selectivity. compare with lines 50-51
```
Results more consistent dome-shaped selectivity pattern by index, similar age comp residual patterns. Compare likelihood:
```{r}
check_convergence(plaice_model3) # Age 9+ fixed selectivity to 1
check_convergence(plaice_model5) # Age 9+ fixed selectivity at 0.5 and ages 4 & 5 fixed at 1 for index 1 & 2
  # Results in larger likelihood, dome-shaped selectivity, little change in age comp
```
### Sixth iteration fix age 9 at 0.5 and freely estimates remaining ages (answers: is dome selectivity more gradual change if age 4/5 not fixed to 1)
```{r}
# Setwd for this model run
setwd(paste(here::here(), "Model_runs", sep="/"))

##### Data
# Load data
asap3 <- read_asap3_dat(paste(here::here(), "Plaice_noMADMF.dat", sep="/"))
# iid random effects for recruitment only 
NAA_re = list(sigma = "rec") #random about mean
NAA_re$recruit_model = 2 #random effects with a constant mean
NAA_re$recruit_pars = exp(10) #initial guess for mean recruitment
# Selectivity
init_fleet_sel <- list(c(2,0.4)) # logistic, same as in the asap dat file
fix_index_sel[[1]][1] <- 9 # Index NA means do not fix them
fix_index_sel[[2]][1] <- 9
fix_fleet_sel = lapply(1:asap3$dat$n_fleets, function(x) NA) #need this for fleets
init_index_sel[[1]] <- c(0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0, 0)
init_index_sel[[2]] <- c(0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.5, 0, 0)
sel_list <- list( model=c(rep("logistic", asap3$dat$n_fleets), rep("age-specific", asap3$dat$n_indices) ),
                  #re=c( rep("none", 1), "2dar1", rep("none", 3) ) ,
                  #re=c( rep("none", 1),  rep("2dar1", 4) ) ,
                  initial_pars=c(init_fleet_sel, init_index_sel) ,
                  fix_pars=c(fix_fleet_sel, fix_index_sel))

##### Prep WHAM input
input6 <- prepare_wham_input(asap3 = asap3, NAA_re = NAA_re, selectivity = sel_list, model_name = "Plaice_noMADMF6")

###### Fit plaice model
plaice_model6 <- fit_wham(input6, do.osa = FALSE,do.retro=FALSE,do.check=TRUE, MakeADFun.silent = TRUE) #do.check will suggest where to look for and parameters that are challenging to estimate in current config
check_convergence(plaice_model6)

# Generate diagnostics
plot_wham_output(mod = plaice_model6, out.type = 'html')

# Look at selectivity patterns 
plaice_model6$rep$selAA[[2]][1,] #index 1 selectivity
plaice_model6$rep$selAA[[3]][1,] #index 2 selectivity. compare with lines 50-51
```
Results in lower estimates of selectivity than plaice_model5, but pattern is similar to plaice_model3 with highest selectivity for age 9+. plaice_model3 or plaice_model5 still appear to be the best candidates



### Seventh iteration builds on iteration 5
Fix selectivity for age 9 near estimate for age 8 from plaice_model3 (0.49969888, 0.516221002), fix ages 4 and 5 (index 1 and 2 respectively) at 1, use logistic normal age comps treating 0s as missing
```{r}
# Setwd for this model run
setwd(paste(here::here(), "Model_runs", sep="/"))

##### Data
# Load data
asap3 <- read_asap3_dat(paste(here::here(), "Plaice_noMADMF.dat", sep="/"))
# iid random effects for recruitment only 
NAA_re = list(sigma = "rec") #random about mean
NAA_re$recruit_model = 2 #random effects with a constant mean
NAA_re$recruit_pars = exp(10) #initial guess for mean recruitment
# Selectivity
init_fleet_sel <- list(c(2,0.4)) # logistic, same as in the asap dat file
fix_index_sel <- NULL
fix_index_sel[[1]] <- c(4,9) # Index NA means do not fix them
fix_index_sel[[2]] <- c(5,9)
fix_fleet_sel = lapply(1:asap3$dat$n_fleets, function(x) NA) #need this for fleets
init_index_sel[[1]] <- c(0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0, 0)
init_index_sel[[2]] <- c(0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.5, 0, 0)
sel_list <- list( model=c(rep("logistic", asap3$dat$n_fleets), rep("age-specific", asap3$dat$n_indices) ),
                  #re=c( rep("none", 1), "2dar1", rep("none", 3) ) ,
                  #re=c( rep("none", 1),  rep("2dar1", 4) ) ,
                  initial_pars=c(init_fleet_sel, init_index_sel) ,
                  fix_pars=c(fix_fleet_sel, fix_index_sel))

##### Prep WHAM input
input7 <- prepare_wham_input(asap3 = asap3, NAA_re = NAA_re, selectivity = sel_list, age_comp = "logistic-normal-miss0", model_name = "Plaice_noMADMF7")

###### Fit plaice model
plaice_model7 <- fit_wham(input7, do.osa = FALSE,do.retro=FALSE,do.check=TRUE, MakeADFun.silent = TRUE) #do.check will suggest where to look for and parameters that are challenging to estimate in current config
check_convergence(plaice_model7)

# Generate diagnostics
plot_wham_output(mod = plaice_model7, out.type = 'html')

# Look at selectivity patterns 
plaice_model7$rep$selAA[[2]][1,] #index 1 selectivity
plaice_model7$rep$selAA[[3]][1,] #index 2 selectivity. compare with lines 50-51
```
Compared to plaice_model5, this model had increased recruitment CV over timeseries, lower estimates of full F, generally smaller poplulation size over time, full catch selectivity by age 6ish rather than 9, lower overall estimates of selectivity except where fixed 

### Eighth iteration same as 3 but lognormal age comp likelihood
```{r}
# Setwd for this model run
setwd(paste(here::here(), "Model_runs", sep="/"))

##### Data
# Load data
asap3 <- read_asap3_dat(paste(here::here(), "Plaice_noMADMF.dat", sep="/"))
# iid random effects for recruitment only 
NAA_re = list(sigma = "rec") #random about mean
NAA_re$recruit_model = 2 #random effects with a constant mean
NAA_re$recruit_pars = exp(10) #initial guess for mean recruitment
# Selectivity
init_fleet_sel <- list(c(2,0.4)) # logistic, same as in the asap dat file
fix_index_sel = lapply(1:asap3$dat$n_indices, function(x) 9) # Index NA means do not fix them
fix_fleet_sel = lapply(1:asap3$dat$n_fleets, function(x) NA) #need this for fleets
init_index_sel = lapply(1:asap3$dat$n_indices, function(x) c(rep(0.5,8),1,0,0))
sel_list <- list( model=c(rep("logistic", asap3$dat$n_fleets), rep("age-specific", asap3$dat$n_indices) ),
                  #re=c( rep("none", 1), "2dar1", rep("none", 3) ) ,
                  #re=c( rep("none", 1),  rep("2dar1", 4) ) ,
                  initial_pars=c(init_fleet_sel, init_index_sel) ,
                  fix_pars=c(fix_fleet_sel, fix_index_sel))

##### Prep WHAM input
input8 <- prepare_wham_input(asap3 = asap3, NAA_re = NAA_re, selectivity = sel_list, age_comp = "logistic-normal-miss0", model_name = "Plaice_noMADMF8")

###### Fit plaice model
plaice_model8 <- fit_wham(input8, do.osa = FALSE,do.retro=FALSE,do.check=TRUE, MakeADFun.silent = TRUE) #do.check will suggest where to look for and parameters that are challenging to estimate in current config
check_convergence(plaice_model8)

# Generate diagnostics
plot_wham_output(mod = plaice_model8, out.type = 'html')

# Look at selectivity patterns 
plaice_model8$rep$selAA[[2]][1,] #index 1 selectivity
plaice_model8$rep$selAA[[3]][1,] #index 2 selectivity. compare with lines 50-51
```
Improved fit over plaice_model7, large negative fleet age_comp residuals for age 4, larger residuals in general compared to plaice_model7, age 9+ larger selectivity than age 8

### Ninth iteration builds on iteration 7
Fix selectivity for age 9 near estimate for age 8 from plaice_model8 (0.47896143, 0.508556168) instead of plaice_model3, fix ages 4 and 5 (index 1 and 2 respectively) at 1, use logistic normal age comps treating 0s as missing
```{r}
# Setwd for this model run
setwd(paste(here::here(), "Model_runs", sep="/"))

##### Data
# Load data
asap3 <- read_asap3_dat(paste(here::here(), "Plaice_noMADMF.dat", sep="/"))
# iid random effects for recruitment only 
NAA_re = list(sigma = "rec") #random about mean
NAA_re$recruit_model = 2 #random effects with a constant mean
NAA_re$recruit_pars = exp(10) #initial guess for mean recruitment
# Selectivity
init_fleet_sel <- list(c(2,0.4)) # logistic, same as in the asap dat file
fix_index_sel <- NULL
fix_index_sel[[1]] <- c(4,9) # Index NA means do not fix them
fix_index_sel[[2]] <- c(5,9)
fix_fleet_sel = lapply(1:asap3$dat$n_fleets, function(x) NA) #need this for fleets
init_index_sel[[1]] <- c(0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.5, 0.47, 0, 0)
init_index_sel[[2]] <- c(0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.50, 0, 0)
sel_list <- list( model=c(rep("logistic", asap3$dat$n_fleets), rep("age-specific", asap3$dat$n_indices) ),
                  #re=c( rep("none", 1), "2dar1", rep("none", 3) ) ,
                  #re=c( rep("none", 1),  rep("2dar1", 4) ) ,
                  initial_pars=c(init_fleet_sel, init_index_sel) ,
                  fix_pars=c(fix_fleet_sel, fix_index_sel))

##### Prep WHAM input
input9 <- prepare_wham_input(asap3 = asap3, NAA_re = NAA_re, selectivity = sel_list, age_comp = "logistic-normal-miss0", model_name = "Plaice_noMADMF9")

###### Fit plaice model
plaice_model9 <- fit_wham(input9, do.osa = FALSE,do.retro=FALSE,do.check=TRUE, MakeADFun.silent = TRUE) #do.check will suggest where to look for and parameters that are challenging to estimate in current config
check_convergence(plaice_model9)

# Generate diagnostics
plot_wham_output(mod = plaice_model9, out.type = 'html')

# Look at selectivity patterns 
plaice_model9$rep$selAA[[2]][1,] #index 1 selectivity
plaice_model9$rep$selAA[[3]][1,] #index 2 selectivity. compare with lines 50-51
```
Slightly smaller gradient than plaice_model8, improves on gradient for plaice-model7, still has peak for age 9+, large negative age comps for age 4 (fleet & index 1) and age 5 (index 2). DON'T USE THIS MODEL - slightly smaller AIC but residual patterns in age comp

## Compare WHAM models with default age_comp likelihood
```{r}
table.opts <- NULL
table.opts$calc.rho = FALSE
compare_wham_models(list(plaice_model3, # Fix age 9+ to 1
                         plaice_model5), # Fix age 9+ to 0.5, age 4 and 5 to 1
 table.opts=table.opts) 
```
plaice_model3 has lower AIC and smaller gradient but appear to have very similar trends/magnitudes except for specified differences in selectivity

## Compare WHAM models with lognormal likelihood that treats 0 as missing
```{r}
compare_wham_models(list(plaice_model8, # Same as model 3 except for likelihood
                    plaice_model7, # Same as model 5 except for likelihood
                    plaice_model9), # Same as model 7 but age 9+ fixed at values near age 8 estimate from plaice_model8 (result in different value for index1)
                    table.opts = table.opts) 
                         
```

## 3 & 5 Most promising thus far, 
### Tenth iteration
Model 3 with survey cv increased to 0.3
```{r}
# Setwd for this model run
setwd(paste(here::here(), "Model_runs", sep="/"))

##### Data
# Load data
asap3 <- read_asap3_dat(paste(here::here(), "Plaice_noMADMF_HighSurvCV.dat", sep="/"))
# iid random effects for recruitment only 
NAA_re = list(sigma = "rec") #random about mean
NAA_re$recruit_model = 2 #random effects with a constant mean
NAA_re$recruit_pars = exp(10) #initial guess for mean recruitment
# Selectivity
init_fleet_sel <- list(c(2,0.4)) # logistic, same as in the asap dat file
fix_index_sel = lapply(1:asap3$dat$n_indices, function(x) 9) # Index NA means do not fix them
fix_fleet_sel = lapply(1:asap3$dat$n_fleets, function(x) NA) #need this for fleets
init_index_sel = lapply(1:asap3$dat$n_indices, function(x) c(rep(0.5,8),1,0,0))
sel_list <- list( model=c(rep("logistic", asap3$dat$n_fleets), rep("age-specific", asap3$dat$n_indices) ),
                  #re=c( rep("none", 1), "2dar1", rep("none", 3) ) ,
                  #re=c( rep("none", 1),  rep("2dar1", 4) ) ,
                  initial_pars=c(init_fleet_sel, init_index_sel) ,
                  fix_pars=c(fix_fleet_sel, fix_index_sel))

##### Prep WHAM input
input10 <- prepare_wham_input(asap3 = asap3, NAA_re = NAA_re, selectivity = sel_list, model_name = "Plaice_noMADMF10")

###### Fit plaice model
plaice_model10 <- fit_wham(input10, do.osa = FALSE,do.retro=FALSE,do.check=TRUE, MakeADFun.silent = TRUE) #do.check will suggest where to look for and parameters that are challenging to estimate in current config
check_convergence(plaice_model10)

# Generate diagnostics
plot_wham_output(mod = plaice_model10, out.type = 'html')

# Look at selectivity patterns 
plaice_model10$rep$selAA[[2]][1,] #index 1 selectivity
plaice_model10$rep$selAA[[3]][1,] #index 2 selectivity. compare with lines 50-51
```
age 9+ still has highest selectivity estimate, no strong differences in residual patterns

### Eleventh iteration
plaice_model5 with survey CV increased to 0.3
```{r}
# Setwd for this model run
setwd(paste(here::here(), "Model_runs", sep="/"))

##### Data
# Load data
asap3 <- read_asap3_dat(paste(here::here(), "Plaice_noMADMF_HighSurvCV.dat", sep="/"))
# iid random effects for recruitment only 
NAA_re = list(sigma = "rec") #random about mean
NAA_re$recruit_model = 2 #random effects with a constant mean
NAA_re$recruit_pars = exp(10) #initial guess for mean recruitment
# Selectivity
init_fleet_sel <- list(c(2,0.4)) # logistic, same as in the asap dat file
fix_index_sel <- NULL
fix_index_sel[[1]] <- c(4,9) # Index NA means do not fix them
fix_index_sel[[2]] <- c(5,9)
fix_fleet_sel = lapply(1:asap3$dat$n_fleets, function(x) NA) #need this for fleets
init_index_sel[[1]] <- c(0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0, 0)
init_index_sel[[2]] <- c(0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.5, 0, 0)
sel_list <- list( model=c(rep("logistic", asap3$dat$n_fleets), rep("age-specific", asap3$dat$n_indices) ),
                  #re=c( rep("none", 1), "2dar1", rep("none", 3) ) ,
                  #re=c( rep("none", 1),  rep("2dar1", 4) ) ,
                  initial_pars=c(init_fleet_sel, init_index_sel) ,
                  fix_pars=c(fix_fleet_sel, fix_index_sel))

##### Prep WHAM input
input11 <- prepare_wham_input(asap3 = asap3, NAA_re = NAA_re, selectivity = sel_list, model_name = "Plaice_noMADMF11")

###### Fit plaice model
plaice_model11 <- fit_wham(input11, do.osa = FALSE,do.retro=FALSE,do.check=TRUE, MakeADFun.silent = TRUE) #do.check will suggest where to look for and parameters that are challenging to estimate in current config
check_convergence(plaice_model11)

# Generate diagnostics
plot_wham_output(mod = plaice_model11, out.type = 'html')

# Look at selectivity patterns 
plaice_model11$rep$selAA[[2]][1,] #index 1 selectivity
plaice_model11$rep$selAA[[3]][1,] #index 2 selectivity. compare with lines 50-51
```
Smaller gradient than plaice_model10, indices don't have peak for age 9+, more dome shaped, higher AIC than first model, fleet selectivity shifted left

## Compare WHAM models with default age_comp likelihood and higher survey CV
```{r}
table.opts <- NULL
table.opts$calc.rho = FALSE
compare_wham_models(list(plaice_model10, # Fix age 9+ to 1
                         plaice_model11), # Fix age 9+ to 0.5, age 4 and 5 to 1
 table.opts=table.opts) 
```
Models 3 and 5 still appear to be best models, worth having a conversation about how selectivity constrained, possibility that peak for age 9+ either 1) poorly informed since few samples for older fish (in which case using logistic normal may be better since fishery fully selected at age 6ish rather than 8ish) or 2) is influenced by the definition of the plus group.

Compare models 3 and 5
```{r}
table.opts <- NULL
table.opts$calc.rho = FALSE
compare_wham_models(list(plaice_model3, # Fix age 9+ to 1
                         plaice_model5), # Fix age 9+ to 0.5, age 4 and 5 to 1
 table.opts=table.opts) 
```


# Test environmental link with recruitment
Take base model 3 before data updated (i.e. still using VPA data) and add in bottom temperature link with recruitment.

Load annual bottom temperature from FVCOM:
```{r}
load(paste(here::here(), "data", "ALLyearly_bottomtemp_clip.RData", sep="/"))
annualBT <- ALLyearly_bottomtemp_clip
sigmas <- rep(0.1, nrow(annualBT)) # Add sigmas, need real info for this 
annualBT <- cbind(annualBT, sigmas)
annualBT <- filter(annualBT, as.numeric(Year) > 1978, as.numeric(Year) < 2019) # Filter to match timeframe of other data
annualBT$Year <- as.numeric(annualBT$Year)
head(annualBT)
```

Make a data.frame specifying different recruitment models to explore:
```{r}
df.mods <- data.frame(Recruitment = c(2,2,2,2), # Random about mean
                      ecov_process = c('rw', 'ar1', 'rw', 'ar1'), # random walk='rw' and AR1='ar1'
                      ecov_how = c(0,0,2,2), # no effect=0, limiting effect=2
                      ecov_where = c("none", "none", "recruit", "recruit")) # Where does environment impact population, none when how = no effect
n.mods <- nrow(df.mods)
df.mods$Model <- paste0("ecoMod", 1:n.mods)
df.mods <- dplyr::select(df.mods,Model, tidyselect::everything()) # Moves Model column to first column
```

Fit model with environmental link on recruitment: !!! Ecov_beta causing problems, not sure what this does, not able to turn off
```{r}
# Setwd for this model run
setwd(paste(here::here(), "Model_runs", sep="/"))

# Loop over possible recruitment models
for(imod in 1:n.mods){
  print(paste("Model",imod))
  ##### Data
  # Setup environmental data and options
  ecov <- list(
    label = "BT",
    mean = as.matrix(annualBT$Avg_bottom_temp),
    logsigma = as.matrix(log(annualBT$sigmas)),
    year = as.numeric(annualBT$Year),
    use_obs = matrix(1, ncol = 1, nrow=nrow(annualBT)), # use all obs =1
    lag = 1, # BT in year t impact R in year t+1
    process_model = df.mods$ecov_process[imod],
    where = df.mods$ecov_where[imod],
    how = df.mods$ecov_how[imod]
  )

# Load data
asap3 <- read_asap3_dat(paste(here::here(), "Plaice_noMADMF.dat", sep="/"))
# iid random effects for recruitment only 
NAA_re = list(sigma = "rec") #random about mean
NAA_re$recruit_model = 2 #random effects with a constant mean
NAA_re$recruit_pars = exp(10) #initial guess for mean recruitment
# Selectivity
init_fleet_sel <- list(c(2,0.4)) # logistic, same as in the asap dat file
fix_index_sel = lapply(1:asap3$dat$n_indices, function(x) 9) # Index NA means do not fix them
fix_fleet_sel = lapply(1:asap3$dat$n_fleets, function(x) NA) #need this for fleets
init_index_sel = lapply(1:asap3$dat$n_indices, function(x) c(rep(0.5,8),1,0,0))
sel_list <- list( model=c(rep("logistic", asap3$dat$n_fleets), rep("age-specific", asap3$dat$n_indices) ),
                  #re=c( rep("none", 1), "2dar1", rep("none", 3) ) ,
                  #re=c( rep("none", 1),  rep("2dar1", 4) ) ,
                  initial_pars=c(init_fleet_sel, init_index_sel) ,
                  fix_pars=c(fix_fleet_sel, fix_index_sel))

##### Prep WHAM input
input <- prepare_wham_input(asap3 = asap3, 
                            NAA_re = NAA_re, 
                            selectivity = sel_list, 
                            ecov=ecov,
                            model_name = "Plaice_noMADMF3_envR")
# if(df.mods$ecov_how[imod]!=0){ # When env covariate considered also specify Ecov_beta effect on recruitment
#   input$par$Ecov_beta[4,1,1,] = 0.5
#   input$map$Ecov_beta = rep(NA,44)
# }


###### Fit plaice model
plaice_model_ecoTest <- fit_wham(input, do.osa = TRUE,do.retro=TRUE,do.check=TRUE, MakeADFun.silent = TRUE) #do.check will suggest where to look for and parameters that are challenging to estimate in current config

###### Save model
saveRDS(plaice_model_ecoTest, file=paste0(df.mods$Model[imod], ".rds"))

###### Plot output in new subfolder
plot_wham_output(mod=plaice_model_ecoTest, dir.main=file.path(getwd(), df.mods$Model[imod]), out.type='html')

} # End loop over R models
```

Check model convergence
```{r}
# Form model list
mod.list <- paste0(df.mods$Model,".rds")
mods <- lapply(mod.list, readRDS)

# Check convergence
convInfo <- lapply(mods, function(x) capture.output(check_convergence(x)))
for(imod in 1:n.mods){
  cat(paste0("Model ", imod, ":"), convInfo[[imod]], "", sep='\n')
}
```

Compare models
```{r}
# Make model table prettier
df.mods$Recruitment <- dplyr::recode(df.mods$Recruitment, `2`='Random', `0`='None')
df.mods$ecov_how <- dplyr::recode(df.mods$ecov_how, `0`='NoEffect', `2`='Limiting')

# Get convergence info
opt_conv = 1-sapply(mods, function(x) x$opt$convergence)
ok_sdrep = sapply(mods, function(x) if(x$na_sdrep==FALSE & !is.na(x$na_sdrep)) 1 else 0)
df.mods$conv <- as.logical(opt_conv)
df.mods$pdHess <- as.logical(ok_sdrep)
df.mods$NLL <- sapply(mods, function(x) round(x$opt$objective,3))

# Start here with AIC and Mohn's rho calculations !!!
```

Calculate AIC & Mohn's rho for converged models
```{r}
not_conv <- !df.mods$conv | !df.mods$pdHess
mods2 <- mods
mods2[not_conv] <- NULL
df.aic.tmp <- as.data.frame(compare_wham_models(mods2, table.opts=list(sort=FALSE, calc.rho=T))$tab)
df.aic <- df.aic.tmp[FALSE,]
ct = 1
for(i in 1:n.mods){
  if(not_conv[i]){
    df.aic[i,] <- rep(NA,5)
  } else {
    df.aic[i,] <- df.aic.tmp[ct,]
    ct <- ct + 1
  }
}
df.mods <- cbind(df.mods, df.aic)
df.mods <- df.mods[order(df.mods$dAIC, na.last=TRUE),]
df.mods[is.na(df.mods$AIC), c('dAIC','AIC','rho_R','rho_SSB','rho_Fbar')] <- "---"
rownames(df.mods) <- NULL
```

Print and save results
```{r}
print(df.mods)
save("df.mods", file = "testPlaiceWithEnv")
```

# Try once data updated
- Next try changing the age comp logistic normal settings (not clear to me difference between 0, 0or1... other options)

- Also rerun above models with retros, see if there are clear/big differences

- Next up may want to do same adjustment for  fleet selectivity

- Time-varying maturity?



# Notes on data
Debugging using source code for read_asap3_dat
```{r}
# filename <- paste(here::here(), "Gulf_of_Maine_cod_WHAM_example", "codGOMcopy.dat", sep="/") # Debug example cod data with additional ages (10-11) and years added(1980-1981)
filename<- "Plaice.dat" # Debug plaice dataset

# Code from source function definition
char.lines <- readLines(filename)
  com.ind <- which(substring(char.lines,1,1) == "#")
  #print(com.ind)
  dat.start <- com.ind[c(which(diff(com.ind)>1), length(com.ind))]
  comments <- char.lines[dat.start]
  #print(comments)
  #print(dat.start)
  #print(length(dat.start))
  dat <- list()
  ind <- 0
  dat$n_years <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$year1 <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$n_ages <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$n_fleets <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  #print(dat)
  #print(ind)
  dat$n_fleet_sel_blocks <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$n_indices <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)

  dat$M <- matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_years*dat$n_ages), dat$n_years, dat$n_ages, byrow = TRUE)
  dat$fec_opt <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$fracyr_spawn <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$maturity <- matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_years*dat$n_ages), dat$n_years, dat$n_ages, byrow = TRUE)
  dat$n_WAA_mats <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$WAA_mats <- lapply(1:dat$n_WAA_mats, function(x) matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind+x], n = dat$n_years*dat$n_ages), dat$n_years, dat$n_ages, byrow = TRUE))

  ind <- ind+dat$n_WAA_mats
  npt <- dat$n_fleets * 2 + 2 + 2
  dat$WAA_pointers <- sapply(1:npt, function(x) scan(filename, quiet=T, what = integer(), skip = dat.start[ind+1]+x-1, n = 1))
  ind <- ind + 1
  # print(ind)

  dat$sel_block_assign <- lapply(1:dat$n_fleets, function(x) scan(filename, quiet=T, what = integer(), skip = dat.start[ind+x], n = dat$n_years))
  ind <- ind+dat$n_fleets
  dat$sel_block_option <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = dat$n_fleet_sel_blocks)
  # print(ind)
  # print(dat.start[ind])
  dat$sel_ini <- lapply(1:dat$n_fleet_sel_blocks, function(x) matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind+x], n = 4*(dat$n_ages+6)), dat$n_ages+6, 4, byrow = TRUE))
  ind <- ind + dat$n_fleet_sel_blocks
  dat$fleet_sel_start_age <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = dat$n_fleets)
  dat$fleet_sel_end_age <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = dat$n_fleets)
  dat$Frep_ages <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 2)
  dat$Frep_type <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$use_like_const <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$release_mort <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_fleets)

  dat$CAA_mats <- lapply(1:dat$n_fleets, function(x) matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind+x], n = dat$n_years*(dat$n_ages+1)), dat$n_years, dat$n_ages+1, byrow = TRUE))
  ind <- ind + dat$n_fleets
  dat$DAA_mats <- lapply(1:dat$n_fleets, function(x) matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind+x], n = dat$n_years*(dat$n_ages+1)), dat$n_years, dat$n_ages+1, byrow = TRUE))
  ind <- ind + dat$n_fleets
  dat$prop_rel_mats <- lapply(1:dat$n_fleets, function(x) matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind+x], n = dat$n_years*(dat$n_ages)), dat$n_years, dat$n_ages, byrow = TRUE))
  ind <- ind + dat$n_fleets
  # print(ind)

  dat$index_units <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$index_acomp_units <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$index_WAA_pointers <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$index_month <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$index_sel_choice <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$index_sel_option <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$index_sel_start_age <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$index_sel_end_age <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$use_index_acomp <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$use_index <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$index_sel_ini <- lapply(1:dat$n_indices, function(x) matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind+x], n = 4*(dat$n_ages+6)), dat$n_ages+6, 4, byrow = TRUE))
  ind <- ind + dat$n_indices
  # print(dat$n_indices)
  #stop()
  # print(dat$index_sel_ini)
  dat$IAA_mats <- lapply(1:dat$n_indices, function(x) matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind+x], n = dat$n_years*(dat$n_ages+4)), dat$n_years, dat$n_ages+4, byrow = TRUE))
  ind <- ind + dat$n_indices
  # print(ind)

  dat$phase_F1 <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$phase_F_devs <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$phase_rec_devs <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$phase_N1_devs <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$phase_q <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$phase_q_devs <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$phase_SR_scalar <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$phase_steepness <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$recruit_cv <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_years)

  dat$lambda_index <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$lambda_catch <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_fleets)
  dat$lambda_discard <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_fleets)

  dat$catch_cv <- matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_years*dat$n_fleets), dat$n_years, dat$n_fleets, byrow = TRUE)
  dat$discard_cv <- matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_years*dat$n_fleets), dat$n_years, dat$n_fleets, byrow = TRUE)
  dat$catch_Neff <- matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_years*dat$n_fleets), dat$n_years, dat$n_fleets, byrow = TRUE)
  dat$discard_Neff <- matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_years*dat$n_fleets), dat$n_years, dat$n_fleets, byrow = TRUE)
  # print(ind)

  dat$lambda_F1 <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_fleets)
  dat$cv_F1 <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_fleets)
  dat$lambda_F_devs <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_fleets)
  dat$cv_F_devs <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_fleets)

  dat$lambda_N1_devs <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$cv_N1_devs <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$lambda_rec_devs <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = 1)

  dat$lambda_q <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$cv_q <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)

  dat$lambda_q_devs <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$cv_q_devs <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)

  dat$lambda_steepness <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$cv_steepness <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = 1)

  dat$lambda_SR_scalar <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$cv_SR_scalar <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = 1)
  # print(ind)

  dat$N1_flag <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$N1_ini <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_ages)
  dat$F1_ini <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_fleets)
  dat$q_ini <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = dat$n_indices)
  dat$SR_scalar_type <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$SR_scalar_ini <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$steepness_ini <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$Fmax <- scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$ignore_guesses <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  # print(ind)

  dat$do_proj <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$dir_fleet <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = dat$n_fleets)
  dat$nfinalyear <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  n <- dat$nfinalyear-dat$year1-dat$n_years+1
  # print(n)
  # print(ind)
  # print(dat.start[ind])
  if(n>0) dat$proj_ini <- matrix(scan(filename, quiet=T, what = double(), skip = dat.start[ind <- ind + 1], n = n*5), n, 5, byrow = TRUE)
  else dat$proj_ini <- matrix(nrow = 0, ncol = 5)
  dat$doMCMC <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$MCMC_nyear_opt <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$MCMC_nboot <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$MCMC_nthin <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$MCMC_nseed <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$fill_R_opt <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$R_avg_start <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$R_avg_end <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$make_R_file <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
  dat$testval <- scan(filename, quiet=T, what = integer(), skip = dat.start[ind <- ind + 1], n = 1)
```

Debugging WHAM input using prepare_wham_input source code
```{r}
options(error = function() traceback(3))
prepare_wham_input(asap3, basic_info$n_indices)

test <- read_asap3_dat("Plaice.dat")
test_info = list(n_indices = 4)
prepare_wham_input(test, basic_info = test_info)
asap3 = test
model_name = "Test"
basic_info = NULL
recruit_model = 2
ecov=NULL
selectivity=NULL
M=NULL
NAA_re=NULL
age_comp=NULL

data = list()
	par = list()
	map = list()
	random = character()
  input = list(
  	data = data,
  	par = par,
  	map = map,
  	random = random,
  	years = NULL, years_full = NULL, ages.lab = NULL, model_name = model_name, asap3 = asap3)


  if(is.null(basic_info)){ basic_info = list(recruit_model = recruit_model)} else {basic_info$recruit_model = recruit_model}

  waa_opts = NULL
  waa_names = c("waa")
  if(any(names(basic_info) %in% waa_names)) waa_opts = basic_info[waa_names]

	catch_opts = NULL
  catch_names = c("n_fleets","agg_catch", "catch_paa", "catch_cv","catch_Neff", "use_catch_paa", "selblock_pointer_fleets")
  if(any(names(basic_info) %in% catch_names)) catch_opts = basic_info[catch_names]

  index_opts = NULL
  index_names = c("n_indices", "agg_indices", "agg_index_paa", "fracyr_indices", "index_cv", "index_Neff", "units_indices",
  	"units_index_paa", "use_indices", "use_index_paa", "selblock_pointer_indices")
  if(any(names(basic_info) %in% index_names)) index_opts = basic_info[index_names]

  F_opts = NULL
  F_names = c("F")
  if(any(names(basic_info) %in% F_names)) F_opts = basic_info[F_names]

  waa_opts = NULL
  waa_names = ("waa")
  if(any(names(basic_info) %in% waa_names)) waa_opts = basic_info[waa_names]

  q_opts = NULL
  q_names = c("q","q_lower","q_upper")
  if(any(names(basic_info) %in% q_names)) q_opts = basic_info[q_names]

	if(!is.null(asap3))
	{
	  asap3 = asap3$dat
  	input$asap3 = asap3
	  input$data$n_ages = asap3$n_ages
	  input$data$fracyr_SSB = rep(asap3$fracyr_spawn, asap3$n_years)
	  input$data$mature = asap3$maturity
	  input$data$Fbar_ages = seq(asap3$Frep_ages[1], asap3$Frep_ages[2]) #??? This might be the source of my error
  	input$years <- asap3$year1 + 1:asap3$n_years - 1
	} else
	{
		#if no asap3 is provided, make some default values to
		input = add_basic_info(input, basic_info)
	}

  # print("start")
	#some basic input elements see the function code below
	input = initial_input_fn(input, basic_info)

  # Catch
  input = set_catch(input, catch_opts)
  #print("catch")

  # Indices/surveys
  print(input)
  input = set_indices(input, index_opts)
   #print("indices")

  # WAA in case we want to modify how weight-at age is handled
  input = set_WAA(input, waa_opts)
   #print("WAA")

  # NAA and recruitment options
  input = set_NAA(input, NAA_re)
   #print("NAA")

  input = set_q(input, q_opts)
   #print("q")

  # Selectivity
  input = set_selectivity(input, selectivity)
   #print("selectivity")

  # Age composition model
  input = set_age_comp(input, age_comp)
   #print("age_comp")

  #in case we want to add alternative F options
  input = set_F(input, F_opts)
   #print("F")

 	#set up natural mortality
  input = set_M(input, M)
   #print("M")

	#set up ecov data and parameters. Probably want to make sure to do this after set_NAA.
	input = set_ecov(input, ecov)
   #print("ecov")

  # add vector of all observations for one step ahead residuals ==========================
  input = set_osa_obs(input)
   #print("osa_obs")


  # projection data will always be modified by 'prepare_projection'
  input = set_proj(input, proj.opts = NULL) #proj options are used later after model fit, right?
   #print("proj")

  #set any parameters as random effects
  input = set_map(input)
   #print("map")

  return(input)
  #return(list(data=data, par = par, map = map, random = random, years = model_years, years_full = model_years,
  #  ages.lab = paste0(1:data$n_ages, c(rep("",data$n_ages-1),"+")), model_name = model_name))
}

# function to calcluate reference age for age comp data
#   returns max(age) with non-zero catch for each index/fleet and year
#   -1 if not more than 1 age with non-zero catch (acomp not fit)
get_aref_fn = function(paa){
  n_years = NROW(paa)
  n_ages = NCOL(paa)
  aref = rep(-1, n_years)
  for(y in 1:n_years)
  {
    temp = paa[y,]
    for(a in 1:n_ages) if(temp[a] < 1.0e-15) temp[a] = 0.0
    if (sum(temp > 1.0e-15)>1)
    { #both requirements as well as total catch > 0 to include age comp in objective function
      paa[y,]=temp/sum(temp)
      for(a in 1:n_ages) if(paa[y,a] > 1.0e-15) aref[y] = a
      for(a in n_ages:1)
      {
        if(paa[y,a] > 1.0e-15)
        {
          aref[y] = a #last positive
          break
        }
      }
      #this part is necessary for logistic-normal age comp (type = 5)
      #note the aref can be associated with an observed 0 if needed.
      this_aref = aref[y] - 1 #start one less than last positive
      for(a in this_aref:1)
      {
        if(length(paa[y,a])== 0)
        {
          print(y)
          print(a)
          print(paa[y,])
          print(this_aref)
        }
        if(paa[y,a] > 1.0e-15) break #next to last is positive, don't change aref
        else aref[y] = a #move aref down one.
      }
    }
  }
  return(aref)
}

gen.logit <- function(x, low, upp) return(log((x-low)/(upp-x)))


initial_input_fn = function(input, basic_info){
	#this function is a helper so that this code can be run in other set up functions like change_wham_input
  input$years_full = input$years
  input$ages.lab = paste0(1:input$data$n_ages, c(rep("",input$data$n_ages-1),"+"))
	if(!is.null(basic_info$ages)) {
		if(!is.integer(basic_info$ages) | length(basic_info$ages) != input$data$n_ages){ stop("basic_info$ages has been specified, but it is not an integer vector or it is not = n_ages")
		}else {
  		input$ages.lab = paste0(basic_info$ages, c(rep("",input$data$n_ages-1),"+"))
		}
	}

  input$data$n_years_model = length(input$years)
  input$data$n_years_catch = length(input$years)
  input$data$n_years_indices = length(input$years)
  input$data$recruit_model = basic_info$recruit_model #this is made from argument of the same name to prepare_wham_input
  input$data$which_F_age = rep(input$data$n_ages,input$data$n_years_model) #plus group by default used to define full F and F RP IN projections, only. prepare_projection changes it to properly define selectivity for projections.

  input$data$bias_correct_pe = 1 #bias correct log-normal process errors?
  input$data$bias_correct_oe = 1 #bias correct log-normal observation errors?
  input$data$simulate_state = rep(1,4) #simulate state variables (NAA, M, sel, Ecov)
  input$data$simulate_data = rep(1,3) #simulate data types (catch, indices, Ecov)
  input$data$simulate_period = rep(1,2) #simulate above items for (model years, projection years)
  input$data$percentSPR = 40 #percentage of unfished SSB/R to use for SPR-based reference points
  input$data$percentFXSPR = 100 # percent of F_XSPR to use for calculating catch in projections
  input$data$percentFMSY = 100 # percent of F_XSPR to use for calculating catch in projections
  # data$XSPR_R_opt = 3 #1(3): use annual R estimates(predictions) for annual SSB_XSPR, 2(4): use average R estimates(predictions). See next line for years to average over.
  input$data$XSPR_R_opt = 2 # default = use average R estimates
  input$data$XSPR_R_avg_yrs = 1:input$data$n_years_model - 1 #model year indices (TMB, starts @ 0) to use for averaging recruitment when defining SSB_XSPR (if XSPR_R_opt = 2,4)

  if(!is.null(basic_info$bias_correct_process)) input$data$bias_correct_pe = basic_info$bias_correct_process
  if(!is.null(basic_info$bias_correct_observation)) input$data$bias_correct_oe = basic_info$bias_correct_observation
  if(!is.null(basic_info$simulate_process_error)) input$data$simulate_state = basic_info$simulate_process_error
  if(!is.null(basic_info$simulate_observation_error)) input$data$simulate_data = basic_info$simulate_observation_error
  if(!is.null(basic_info$simulate_period)) input$data$simulate_period = basic_info$simulate_period

  if(!is.null(basic_info$percentSPR)) input$data$percentSPR = basic_info$percentSPR
  if(!is.null(basic_info$percentFXSPR)) input$data$percentFXSPR = basic_info$percentFXSPR
  if(!is.null(basic_info$percentFMSY)) input$data$percentFMSY = basic_info$percentFMSY
  if(!is.null(basic_info$XSPR_R_opt)) input$data$XSPR_R_opt = basic_info$XSPR_R_opt
  if(!is.null(basic_info$XSPR_R_avg_yrs)) input$data$XSPR_R_avg_yrs = basic_info$XSPR_R_avg_yrs}
```

Debug set_indices
```{r}
set_indices(input, index_opts)

# Start function
	data = input$data
	if(is.null(input$asap3)) {
		asap3 = NULL
    if(is.null(index_opts$n_indices)) data$n_indices = 1
    else data$n_indices = index_opts$n_indices
	}else {
  	asap3 = input$asap3
 	  which_indices <- which(asap3$use_index ==1)
	  asap3$n_indices = length(which_indices)
	  asap3$survey_index_units <- asap3$index_units[which_indices]
	  asap3$survey_acomp_units <- asap3$index_acomp_units[which_indices]
	  asap3$survey_WAA_pointers <- asap3$index_WAA_pointers[which_indices]
	  asap3$survey_month <- matrix(asap3$index_month[which_indices], asap3$n_years, asap3$n_indices, byrow = TRUE)
	  asap3$use_survey_acomp <- asap3$use_index_acomp[which_indices]
	  asap3$index_WAA_pointers = asap3$index_WAA_pointers[which_indices]
	  asap3$IAA_mats <- asap3$IAA_mats[which_indices]
	  asap3$use_survey <- asap3$use_index[which_indices]
	  data$n_indices <- asap3$n_indices
	} 
  data$agg_indices = matrix(NA, data$n_years_model, data$n_indices)
  data$use_indices = matrix(1, data$n_years_model, data$n_indices)
  data$agg_index_sigma = matrix(NA, data$n_years_model, data$n_indices)
  data$index_paa = array(NA, dim = c(data$n_indices, data$n_years_model, data$n_ages))
  data$use_index_paa = matrix(1, data$n_years_model, data$n_indices)
  data$index_Neff = matrix(NA, data$n_years_model, data$n_indices)
	if(!is.null(asap3))
	{
	  data$units_indices <- asap3$survey_index_units
	  data$fracyr_indices = (asap3$survey_month-1)/12 #make sure that this is right
  	for(i in 1:data$n_indices) data$agg_indices[,i] = asap3$IAA_mats[[i]][,2]
	  for(i in 1:data$n_indices)
	  {
	    for(y in 1:data$n_years_model) if(asap3$IAA_mats[[i]][y,2] < 1e-15) data$use_indices[y,i] = 0
	  }
	  for(i in 1:data$n_indices) data$agg_index_sigma[,i] = asap3$IAA_mats[[i]][,3]
	  for(i in 1:data$n_indices)
	  {
	    temp = asap3$IAA_mats[[i]][,3 + 1:data$n_ages]
	    temp[which(is.na(temp))] = 0
	    temp[which(temp<0)] = 0
	    data$index_paa[i,,] = temp/apply(temp,1,sum)
	  }
	  for(i in 1:data$n_indices)
	  {
	    if(asap3$use_survey_acomp[i] != 1){ data$use_index_paa[,i] = 0
	    }else for(y in 1:data$n_years_model) if(asap3$IAA_mats[[i]][y,4 + data$n_ages] < 1e-15 | sum(data$index_paa[i,y,] > 1e-15)<2) data$use_index_paa[y,i] = 0
	  }
	  data$units_index_paa <- asap3$survey_acomp_units
	  for(i in 1:data$n_indices) data$index_Neff[,i] = asap3$IAA_mats[[i]][,4 + data$n_ages]

    data$selblock_pointer_indices = matrix(rep(asap3$n_fleet_sel_blocks + 1:data$n_indices, each = data$n_years_model), data$n_years_model, data$n_indices)
	}
	else
	{
		if(is.null(index_opts$units_indices)) data$units_indices = rep(1,data$n_indices) #biomass
		else data$units_indices = index_opts$units_indices
		
		if(is.null(index_opts$fracyr_indices)) data$fracyr_indices =matrix(0.5, data$n_years_model, data$n_indices)
		else data$fracyr_indices = index_opts$fracyr_indices
		
		if(is.null(index_opts$agg_indices)) data$agg_indices[] = 10
		else data$agg_indices[] = index_opts$agg_indices

		if(is.null(index_opts$index_cv)) data$agg_index_sigma[] = 0.3
		else data$agg_index_sigma[] = index_opts$index_cv

		if(is.null(index_opts$index_paa)) data$index_paa[] = 1/data$n_ages
		else data$index_paa[] = index_opts$index_paa

		if(is.null(index_opts$units_index_paa)) data$units_index_paa = rep(2,data$n_indices) #numbers
		else data$units_index_paa = index_opts$units_index_paa

		if(is.null(index_opts$index_Neff)) data$index_Neff[] = 100
		else data$index_Neff[] = index_opts$index_Neff

    if(is.null(index_opts$selblock_pointer_indices)) data$selblock_pointer_indices = matrix(rep(1:data$n_indices, each = data$n_years_model), data$n_years_model, data$n_indices) + data$n_fleets
    else data$selblock_pointer_indices = index_opts$selblock_pointer_indices
	}

  data$agg_index_sigma[which(data$agg_index_sigma < 1e-15)] = 100  
  data$agg_index_sigma = sqrt(log(data$agg_index_sigma^2 + 1))
  # for plotting, in years where index is not used set sigma = avg of used years
  tmp <- data$agg_index_sigma
  tmp[data$use_indices == 0] = NA
  mean_agg_ind_sigma <- apply(tmp, 2, mean, na.rm=T)
  for(i in 1:data$n_indices) data$agg_index_sigma[data$use_indices[,i] == 0,i] = mean_agg_ind_sigma[i]
  ################################################################################

  data$index_paa[is.na(data$index_paa)] = 0
  data$index_aref = matrix(NA, data$n_years_model, data$n_indices)
  for(i in 1:data$n_indices) data$index_aref[,i] = get_aref_fn(data$index_paa[i,,])  

  input$par$log_index_sig_scale = rep(0, data$n_indices)
  input$map$log_index_sig_scale = factor(rep(NA, data$n_indices))

	
  input$data = data
  return(input)
# End function


```


